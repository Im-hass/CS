## 📌 HTTP, HTTPS

> **HTTP(Hypertext Transfer Protocol) :** 인터넷에서 데이터를 주고받기 위해 사용되는 프로토콜
> **HTTPS(Hypertext Transfer Protocol Secure) :** HTTP의 보안 버전

- HTTP는 클라이언트(웹 브라우저)와 서버 간에 요청과 응답을 주고받는 방식으로 동작한다.
- HTTPS는 HTTP와 동일한 기능을 제공하지만, 데이터의 암호화와 인증을 추가로 제공하여 보안을 강화한다.
- HTTPS는 SSL(Secure Sockets Layer) 또는 TLS(Transport Layer Security) 프로토콜을 사용하여 데이터를 암호화하고 인증서를 통해 서버의 신원을 확인한다.

### HTTP와 HTTPS의 차이점

|  | HTTP | HTTPS |
| --- | --- | --- |
| 사용 | 단순한 정보 전달이나 웹 페이지의 조회와 같이 보안이 크게 중요하지 않은 경우 사용. | 개인 정보를 전송하는 웹 페이지(예: 로그인, 결제) 및 보안이 필요한 통신에 권장. |
| 보안성 | 데이터가 암호화되지 않고 평문으로 전송하기 때문에 중간에 제3자가 데이터를 가로채거나 변조할 수 있는 보안 위험을 내포함. | HTTP의 보안 버전으로, SSL 또는 TLS 프로토콜을 사용하여 데이터를 암호화 하여 암호화되어 전송되므로 중간에 제3자가 데이터를 엿볼 수 없고, 데이터의 무결성이 보장됨. |
| 포트 번호 | 기본 80 | 기본 443 |
| 인증서 여부 | X | O |
| 검색 엔진 최적화(SEO) | 일부 검색 엔진에서는 보안상의 이유로 HTTP 사이트를 더 낮은 순위로 평가할 수 있음. | 데이터의 보안성을 제공하므로 검색 엔진에서 HTTPS 사이트를 우선적으로 평가할 수 있음. |

### HTTP 요청 방식

> GET, POST, PUT, DELETE 네 가지 주요 방식이 있다.

- **GET**

    - 서버로부터 정보를 요청할 때 사용된다.
    - 주로 웹 페이지를 요청하고 해당 페이지의 내용을 가져올 때 사용된다.
    - URL에 파라미터를 추가하여 데이터를 전송할 수 있다.
    - 또한, GET 요청은 캐싱이 가능하므로 동일한 요청에 대한 응답을 캐시에서 가져올 수 있다.

- **POST**
    
    - 서버에 새로운 데이터를 전송하거나 수정을 요청할 때 사용된다.
    - 주로 폼 데이터를 서버로 제출하거나, 파일을 업로드하거나, 리소스를 생성하기 위해 사용된다.
    - POST 요청은 요청 본문에 데이터를 포함하여 전송하며, 데이터는 URL에 노출되지 않으므로 데이터 보안에 적합하다.

- **PUT**

    - 서버에 새로운 데이터를 저장하거나 기존 데이터를 업데이트할 때 사용된다.
    - 주로 리소스의 전체 내용을 갱신할 때 사용된다.
    - PUT 요청은 전체 엔티티를 서버로 보낸다. 즉, 요청 본문에는 수정하고자 하는 데이터의 전체 내용이 포함되어야 한다.

- **DELETE**

    - 서버에서 리소스를 삭제할 때 사용된다.
    - DELETE 요청을 보내면 서버는 해당 리소스를 삭제한다.
    - 삭제된 리소스는 복구할 수 없으며, 민감한 데이터를 삭제하는 경우 보안을 고려해야 하므로 사용에 주의가 필요하다.

### HTTP의 상태 코드 종류와 설명

- **1XX :** 정보성 상태 코드 (Informational)
    - `100` Continue : 서버가 클라이언트의 요청을 받아들이고 계속 처리하고 있음을 의미.
    - `101` Switching Protocols : 클라이언트의 요청에 따라 프로토콜을 변경하고 있음을 의미.
- **2XX :** 성공 상태 코드 (Successful)
    - `200` OK : 요청이 성공적으로 처리되었음을 의미.
    - `201` Created : 요청에 의해 새로운 리소스가 생성되었음을 의미.
    - `204` No Content : 요청은 성공적으로 처리되었지만, 응답으로 내용이 없음을 의미.
- **3XX :** 리디렉션 상태 코드 (Redirection)
    - `301` Moved Permanently : 요청한 리소스가 새로운 URL로 영구적으로 이동되었음을 의미.
    - `302` Found : 요청한 리소스가 일시적으로 다른 URL로 이동되었음을 의미.
    - `304` Not Modified : 클라이언트의 캐시된 버전이 최신 상태임을 의미. 서버에서 내용을 변경하지 않았음을 알려줌.
- **4XX :** 클라이언트 오류 상태 코드 (Client Error)
    - `400` Bad Request : 잘못된 요청으로 인해 서버가 요청을 이해하지 못함을 의미.
    - `403` Forbidden : 요청된 리소스에 대한 액세스가 거부되었음을 의미.
    - `404` Not Found : 요청한 리소스를 서버에서 찾을 수 없음을 의미.
- **5XX :** 서버 오류 상태 코드 (Server Error)
    - `500` Internal Server Error : 서버 내부에서 오류가 발생함을 의미.
    - `502` Bad Gateway : 게이트웨이나 프록시 서버에서 잘못된 응답을 받았음을 의미.
    - `503` Service Unavailable : 서버가 일시적으로 과부화 상태이거나 유지 보수로 인해 사용할 수 없음을 의미.

### HTTP 캐시와 캐싱

> **캐싱은** 성능 향상과 대역폭 절약을 위한 **개념**이고, **캐시는** 그 개념을 구현하기 위한 구체적인 **저장소.**
>
> **캐싱(Caching) :** 웹 페이지나 리소스를 임시로 저장하고 재사용하는 메커니즘을 의미
> **캐시(Cache) :** 실제로 리소스를 저장하는 저장소를 의미

- 웹 서버로부터 리소스를 가져와서 로컬에 저장하여 다음에 동일한 리소스가 요청될 때 캐시에서 바로 제공한다.
- 웹 성능을 향상시키고 대역폭을 절약할 수 있다.
- 캐시는 캐싱된 리소스를 저장하고 관리한다.
- 캐시는 일반적으로 웹 브라우저, 프록시 서버, CDN(Content Delivery Network) 등에서 사용되며, 캐시된 리소스는 동일한 요청이 발생했을 때 서버로부터 다시 가져오지 않고 캐시에서 직접 제공된다.

<br />
<br />

## 📌 SSL, TLS

> 네트워크 통신에서 데이터 보안과 인증을 위한 **암호화 프로토콜**
웹 서비스에서 **HTTPS를 통해 암호화된 연결을 제공**하는 데 주로 사용된다.

- TLS(Transport Layer Security)은 SSL(Secure Sockets Layer)의 **표준화 버전**으로, **SSL과 TLS는 서로 호환되는 프로토콜**이다.
- 보안 연결을 설정하기 위해 클라이언트와 서버 간에 **핸드셰이크(handshake) 프로세스***를 수행
- **주요 기능**
    - **데이터 암호화 :** 클라이언트와 서버 간에 주고받는 데이터를 암호화하여 외부에서 엿볼 수 없도록 보호한다.
    - **상호 인증 :** 클라이언트와 서버는 서로의 신원을 확인하기 위해 디지털 인증서를 사용하여 상호 인증을 수행한다.
    - **무결성 보호 :** 데이터가 전송 중에 변경되지 않았음을 보장하기 위해 무결성 체크를 수행한다.

<br />

### **핸드셰이크(handshake) 프로세스**

- 클라이언트와 서버 간에 보안 연결을 설정하기 위해 수행되는 절차이다.
1. **클라이언트 Hello(클라이언트 → 서버)**
    
    서버와의 연결을 시작하기 위해 SSL/TLS 버전 및 암호화 알고리즘 등의 정보를 포함한 클라이언트 Hello 메시지를 서버로 전송
    
2. **서버 Hello(서버 → 클라이언트)**
    
    서버는 클라이언트로부터 받은 정보를 기반으로 SSL/TLS 버전 및 암호화 알고리즘 등의 정보를 포함한 서버 Hello 메시지를 클라이언트로 전송
    
3. **인증서 교환(서버 → 클라이언트)**
    
    서버는 클라이언트에게 자체 디지털 인증서를 제공.
    
    인증서는 서버의 공개키를 포함하고 있으며, 클라이언트는 이를 사용하여 서버의 신원을 확인 가능.
    
4. **클라이언트 키 교환(클라이언트 → 서버)**
    
    클라이언트는 서버의 인증서를 검증한 후, 보안 세션에 사용할 임시 세션 키를 생성하고, 서버의 공개키로 암호화하여 서버에게 전송
    
5. **서버 키 교환 및 세션 키 생성**
    
    서버는 클라이언트로부터 받은 암호화된 세션 키를 개인키를 사용하여 복호화하고, 이를 통해 클라이언트와 서버 간의 공유된 세션 키를 생성
    
6. **핸드셰이크 완료(클라이언트 ↔ 서버)**
    
    클라이언트와 서버는 핸드셰이크가 완료되었음을 알리는 메시지를 교환
    
    클라이언트와 서버는 공유된 세션 키를 사용하여 데이터를 암호화하고 복호화할 수 있게 된다.